# 输入一个URL地址

# 域名解析 
  - 浏览器首先搜索浏览器的dns缓存，找是否与url对应的条目，且没有过期，有且没有过期，解析结束。
  - 浏览器查找操作系统的DNS缓存，有且没有过期，解析结束
  - 查询路由器的DNS缓存 
  - ISP DNS缓存
   - 递归查找
      - 向根名称服务器发送解析请求
      - 查询顶级域名所对应的顶级名称服务器，请求查询
      - 查询对应的二级名称服务器 请求查询
      - 三级域名对应的权威名称服务器，请求查询

# 浏览器和IP地址建立TCP连接
  - 第一次握手：建立连接时,客户端发送syn包(syn=j)到服务器,并进入SYN_SEND状态,等待服务器确认； 
  - 第二次握手：服务器收到syn包,必须确认客户的SYN（ack=j+1）,同时自己也发送一个SYN包（syn=k）,即SYN+ACK包,此时服务器进入SYN_RECV状态； 
  - 第三次握手：客户端收到服务器的SYN＋ACK包,向服务器发送确认包ACK(ack=k+1),此包发送完毕,客户端和服务器进入ESTABLISHED状态,完成三次握手.

# 浏览器向服务器发送HTTP请求
  - GET请求

# Server Response（服务器统一响应数据格式）
  - 1xx 信息提示
  - 2xx 操作成功
  - 3xx 重定向码
  - 4xx 客户端错误码
  - 5xx 服务器错误码

# HTML响应

# 浏览器解析HTML代码，并请求代码中的资源（js,css,image）(keep-alive 一次HTTP连接，多个请求)以及渲染
  - 解析HTML文档
      - 浏览器HTML解释器将HTML文档从字节流解释成DOM树（深度遍历）
  - 解析CSS
      - 浏览器对CSS文件内容进行解析，浏览器先查找内联样式，然后CSS文件定义的样式，最后是浏览器默认的样式，产生CSSOM规则树
  - 解析并加载脚本文件
  - 根据DOM树和CSSOM树构建渲染树（render tree）
  - 布局（layout） render树
      - 有了render树，浏览器已经能知道网页中有哪些节点，各个节点的CSS定义以及从属关系，从而计算出每个节点在屏幕中的位置
  - 绘制（painting）render树
      - 按照计算出来的规则，通过显卡，把内容画到屏幕上。
  - 回流（reflow）
      - 当浏览器某个部分发生了点变化影响了布局，需要倒回去重新渲染，这个回退的过程叫回流。reflow从<html>开始递归往下，依次计算所有的节点几何尺寸和位置
  - 重绘（repaint）
      - 改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性时，屏幕的一部分要重绘，但是元素的几何尺寸没有变。



# 浏览器对CSS和JS的解析规则
  - CSS
      - CSS放在head中会阻塞页面的渲染（页面的渲染会等到CSS加载完成）
      - CSS阻塞JS的执行（GUI线程和JS线程是互斥的，因为JS可能会操作CSS
      - CSS不阻塞外部脚本的加载（不阻塞JS的加载，但阻塞JS的执行，因为浏览器都会有预先扫描器）
  - JS
      - 直接引入的JS会阻塞页面的渲染（GUI线程和JS线程互斥）
      - 延迟加载的JS（script标签中添加defer属性） 不阻塞页面的渲染
      - 异步加载的JS（script标签中添加async属性），下载过程不阻塞页面渲染，当下载完成后立即执行，阻塞页面渲染
      - JS不阻塞资源的加载
      - JS顺序执行，阻塞后续JS逻辑的执行